<i>Примечание переводчика. В будущей версии Scala (“Don Giovanni”) <a href="http://www.scala-lang.org/news/roadmap-next">анонсирована</a> поддержка типов объединения (union types). Miles Sabin, широко известный в узких кругах как создатель Shapeless, демонстрирует в <a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/">этой</a> статье 2011 года, как создать типы объединения уже сейчас.<br/>
<b>UPD</b>. Представленный в статье подход не позволяет получить настоящих типов объединения и кроме того может существенно повлиять на время компиляции. Типы пересечения (<code>A with B</code>), использованные в статье, также отличаются от классических, поскольку не обладают свойством коммутативности. Подробности об экспериментальном проекте Dotty, в рамках которого будут решены эти и другие проблемы, можно посмотреть в замечательной <a href="https://d-d.me/scalaworld2015/#/">презентации</a> Дмитрия Петрашко @darkdimius - разработчика компилятора Scala в EPFL.</i>  

Scala имеет очень выразительную систему типов. Однако она не включает (по крайней мере как примитивы) всех вожделенных элементов. Есть несколько поистине полезных типов, подпадающих под эту категорию - это типы полиморфных функций высшего ранга (higher-rank) и рекурсивные структурные типы. Но о них я расскажу подробнее в следующих постах, а сегодня я собираюсь показать вам, как в Scala мы можем создать типы объединения (union types). В ходе объяснения я пролью немного света на изоморфизм Карри-Ховарда и покажу, как использовать его в наших целях.

<img src="https://habrastorage.org/files/427/70e/d92/42770ed92098475fac9f4632be73e3d5.jpg" align="center" />
<cut/>
Итак, для начала, что такое тип объединения? Тип объединения это во многом то, чего вы от него ожидаете: объединение двух (или больше, но я ограничусь только двумя) типов. Значения этого типа включают все значения каждого из объединяемых типов. Что это значит нам поможет выяснить пример, но для начала введём систему обозначений. По причинам, которые станут вскоре понятны, я буду записывать объединение типов <code>T</code> и <code>U</code> с помощью символа операции ИЛИ: <code>T ∨ U</code>. Таким образом объединение типов <code>Int</code> и <code>String</code> записывается как <code>Int ∨ String</code>. Значения этого типа объединения включают все значения типа <code>Int</code> и все значения типа <code>String</code>.

Но что же это значит более конкретно? А значит это то, что если бы мы имели возможность напрямую выразить такой тип в Scala, то мы смогли бы, к примеру, написать так:
<source lang="Scala">
def size(x: Int ∨ String) = x match {
  case i: Int => i
  case s: String => s.length
}

size(23) == 23   // OK
size("foo") == 3 // OK
size(1.0)        // Не OK, ошибка компиляции
</source>
Другими словами, метод <code>size</code> может принимать аргументы либо типа <code>Int</code>, либо типа <code>String</code> (включая их подтипы <code>Null</code> и <code>Nothing</code>), и никакие другие.

Важно подчеркнуть отличие между использованием этого типа объединения и станадартного <code>Either</code>. <code>Either</code>, известный как тип суммы (sum type), это аналог типа объединения в языках не поддерживающих подтипы. Переписывание нашего примера с использованием <code>Either</code> даст нам:
<source lang="Scala">
def size(x: Either[Int, String]) = x match {
  case Left(i) => i
  case Right(s) => s.length
}

size(Left(23)) == 23    // OK
size(Right("foo")) == 3 // OK
</source>
Тип <code>Either[Int, String]</code> может моделировать тип объединения <code>Int ∨ String</code>, так как между ними и их значениями существует соответствие (изоморфизм). Однако абсолютно ясно, что тип <code>Either</code> добивается этого будучи дополнительным уровнем упакованного (boxed) представления, а не как неупакованный (unboxed) примитив системы типов. Можем ли мы создать нечто лучшее, чем <code>Either</code>? Можем ли мы найти способ представления типов объединения в Scala без привлечения упаковки и со всеми ожидаемыми статическими гарантиями?

Оказывается, что мы можем, но на пути к результату нам необходимо совершить объезд через логику первого порядка с помощью <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">изоморфизма Карри-Ховарда</a>. Данный изоморфизм говорит нам, что отношения между типами в системе типов могут рассматриваться как образ отношений между высказываниями в логической системе (и наоборот). Мы можем интерпретировать данное утверждение различными способами в зависимости от того, о какой системе типов мы говорим, и какую логическую систему мы выбрали, но для для нашего обсуждения я проигнорирую большинство деталей и сосредоточусь на простых примерах.

Проиллюстрируем изоморфизм Карри-Ховарда в контексте системы типов с подтипами как в Scala. Можно заметить, что существует соответствие между типами пересечения (<code>A with B</code>) и логической конъюнкцией (<code>A ∧ B</code>); между моими гипотетическими типами объединения (<code>A ∨ B</code>) и логической дизъюнкцией (так же <code>A ∨ B</code>, на что был сделан намёк выше); и между подтипами (<code>A &lt;: B</code>) и логической импликацией (<code>A ⇒ B</code>). В левой колонке представленной ниже таблицы мы имеем отношения подтипов выполняемые в Scala (но в случае типов объединения не выражаемые напрямую в языке), а в правой колонке мы имеем логические формулы полученные из отношений между типами слева путём простой замены <code>with</code> на <code>∧</code> и <code>&lt;:</code> на <code>⇒</code>. В каждом из случаев такая замена даёт логически верную формулу.
<table>
	<tr>
		<td>(A with B) &lt;: A</td>
		<td>(A ∧ B) ⇒ A</td>
	</tr>
	<tr>
		<td>(A with B) &lt;: B</td>
		<td>(A ∧ B) ⇒ B</td>
	</tr>
	<tr>
		<td>A &lt;: (A ∨ B)</td>
		<td>A ⇒ (A ∨ B)</td>
	</tr>
	<tr>
		<td>B &lt;: (A ∨ B)</td>
		<td>B ⇒ (A ∨ B)</td>
	</tr>
</table>
Суть изоморфизма Карри-Ховарда в том, что механический процесс замены всегда сохраняет корректность - верная типовая формула всегда переписывается в верную логическую формулу, и наоборот. И это выполняется не только для конъюнкции, дизъюнкции и импликации. Мы также можем обобщить соответствие на логические формулы включающие отрицание (ключевая операция в сегодняшнем рассмотрении) и кванторы общности и существования.

Что же будет для нас значить добавление отрицания? Конъюнкция двух типов (т.е. <code>A with B</code>) имеет значения, которые являются экземплярами одновременно и <code>A</code>, и <code>B</code>. Подобным же образом мы можем предполагать, что отрицание типа <code>A</code> (я буду записывать его как <code>¬[A]</code>) должно иметь значения, которые не являются экземплярами типа <code>A</code>. Отрицание также не может быть напрямую выражено в языке Scala, но к чему мы придём, предположив, что это не так?

В таком случае мы могли бы использовать изоморфизм Карри-Ховарда и <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD%D1%8B_%D0%B4%D0%B5_%D0%9C%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B0">законы Де Моргана</a>, чтобы получить определение типов объединения из типов пересечения и отрицания. Вот как это могло бы получиться...

Для начала вспомним равенство Де Моргана:
<source>
(A ∨ B) ⇔ ¬(¬A ∧ ¬B)
</source>
Затем применим изоморфизм Карри-Ховарда (используя операцию эквивалентности <code>=:=</code> языка Scala):
<source lang="Scala">
(A ∨ B) =:= ¬[¬[A] with ¬[B]]
</source>
Если бы мы только могли найти способ записи этого в Scala, то наша цель была бы достигнута и мы бы имели наши типы объединения. Так можем ли мы выразить отрицание типа в Scala?

К сожалению, мы не можем. Но, что мы можем сделать, так это преобразовать все наши типы таким образом, чтобы сделать возможным запись отрицания в преобразованном контексте. Затем нам понадобится найти способ заставить всё это работать в оригинальном непреобразованном контексте.

Некоторые читатели возможно были немного удивлены, когда я ранее проиллюстрировал изоморфизм Карри-Ховарда используя типы пересечения в паре с конъюнкцией, типы объединения в паре с дизъюнкцией и отношение подтипов в паре с импликацией. Обычно же типы произведения (product types), т.е. <code>(A, B)</code> моделируют конъюнкцию, типы суммы (<code>Either[A, B]</code>) моделируют дизъюнкцию и типы функций моделируют импликацию. Если мы перепишем нашу предыдущую таблицу с использованием произведений, сумм и функций, то получим следующее:
<table>
	<tr>
		<td>(A, B) => A</td>
		<td>(A ∧ B) ⇒ A</td>
	</tr>
	<tr>
		<td>(A, B) => B</td>
		<td>(A ∧ B) ⇒ B</td>
	</tr>
	<tr>
		<td>A =&gt; Either[A, B]</td>
		<td>A ⇒ (A ∨ B)</td>
	</tr>
	<tr>
		<td>B =&gt; Either[A, B]</td>
		<td>B ⇒ (A ∨ B)</td>
	</tr>
</table>
В левой части мы больше не ожидаем корректности с точки зрения отношения подтипов, вместо этого нам необходимо соблюдение <a href="https://en.wikipedia.org/wiki/Parametricity">принципа параметричности</a>, который позволяет нам определить может ли тип функции быть реализован исходя только лишь из сигнатуры функции. Очевидно, что все сигнатуры функций в левой колонке могут быть реализованы. Для первых двух случаев мы имеем пару <code>(A, B)</code> как аргумент нашей функции, поэтому мы легко можем получить из этой пары значение типа <code>A</code> или <code>B</code>, использовав <code>_1</code> или <code>_2</code>:
<source lang="Scala">
val conj1: ((A, B)) => A = p => p._1
val conj2: ((A, B)) => B = p => p._2
</source>
Во втором и третьем случае аргументами функции являются значения типа <code>A</code> и <code>B</code> соответственно, поэтому мы можем получить результат типа <code>Either[A, B]</code> воспользовавшись конструкторами <code>Left[A]</code> и <code>Right[B]</code>:
<source lang="Scala">
val disj1: A => Either[A, B] = a => Left(a)
val disj2: B => Either[A, B] = b => Right(b)
</source>
Именно в такой форме изоморфизм Карри-Ховарда обычно выражается для языков без подтипов. Однако типы объединения, также как и типы пересечения, по своей сути основаны на подтипах. Поэтому рассмотренное отображение ни в коей степени не поможет нам с объединением. Зато оно может помочь нам с отрицанием, которое является той самой недостающей деталью пазла.

С подтипами или без, наименьший тип (bottom type), представленный в Scala как <code>Nothing</code>, отображается в логическую ложь. Например, все следующие равенства справедливы:
<table>
	<tr>
		<td>A =&gt; Either[A, Nothing]</td>
		<td>A ⇒ (A ∨ false)</td>
	</tr>
	<tr>
		<td>B =&gt; Either[Nothing, B]</td>
		<td>B ⇒ (false ∨ B)</td>
	</tr>
</table>
Это следует из того, что все сигнатуры функций слева реализуемы, а логические формулы справа верны (<a href="http://james-iry.blogspot.ru/2011/05/why-eager-languages-dont-have-products.html">пост</a> Джеймса Айри объясняет почему я не показываю случай соответствия произведений/конъюнкций). Теперь подумаем, что соответствует функции со следующей сигнатурой:
<source lang="Scala">
A => Nothing
</source>
На правой логической стороне изоморфизма Карри-Ховарда эта сигнатура отображается в формулу <code>A ⇒ false</code>, которая эквивалентна <code>¬A</code>. Это кажется вполне интуитивно разумным - не существует значений типа <code>Nothing</code>, следовательно сигнатура <code>A => Nothing</code> не может быть реализована (кроме как выбрасыванием исключения, но в нашем случае это не позволено).

Теперь давайте посмотрим, что будет, если мы используем эту сигнатуру как наше представление отрицания типа,
<source lang="Scala">
type ¬[A] = A => Nothing
</source>
и применим его в контексте законов Де Моргана, чтобы получить тип объединения:
<source lang="Scala">
type ∨[T, U] = ¬[¬[T] with ¬[U]]
</source>
Теперь мы можем проверить наш тип используя Scala REPL:
<source lang="Scala">
scala> type ¬[A] = A => Nothing
defined type alias $u00AC

scala> type ∨[T, U] = ¬[¬[T] with ¬[U]]
defined type alias $u2228

scala> implicitly[Int <:< (Int ∨ String)]
<console>:11: error: Cannot prove that Int <:< 
  ((Int) => Nothing with (String) => Nothing) => Nothing.
       implicitly[Int <:< (Int ∨ String)]
</source>
REPL показывает нам, что решение ещё не совсем получено. Выражение <code>implicitly[Int <:< (Int ∨ String)]</code> спрашивает компилятор, может ли он доказать, что <code>Int</code> является подтипом <code>Int ∨  String</code>, что должно быть справедливо для типа объединения.

Что же пошло не так? Проблема в том, что мы преобразовали типы в правой части оператора <code>&lt;:&lt;</code> в типы функций, чтобы использовать отрицание типа, заданное как <code>A =&gt; Nothing</code>. Это значит, то  сам тип объединения является типом функции. Но это, очевидно, не согласуется с тем, чтобы <code>Int</code> был подтипом типа объединения, что и показывает сообщение об ошибке от REPL. Чтобы устранить ошибку мы должны также преобразовать левую часть оператора <code>&lt;:&lt;</code> в тип, который был бы подтипом типа в правой части.

Какой же может быть эта трансформация? Как насчёт двойного отрицания?
<source lang="Scala">
type ¬¬[A] = ¬[¬[A]]
</source>
Давайте посмотрим, что на это скажет компилятор:
<source lang="Scala">
scala> type ¬¬[A] = ¬[¬[A]]
defined type alias $u00AC$u00AC

scala> implicitly[¬¬[Int] <:< (Int ∨ String)]
res5: <:<[((Int) => Nothing) => Nothing,
  ((Int) => Nothing with (String) => Nothing) => Nothing] =
    <function1>

scala> implicitly[¬¬[String] <:< (Int ∨ String)]
res6: <:<[((String) => Nothing) => Nothing,
  ((Int) => Nothing with (String) => Nothing) => Nothing] =
    <function1>
</source>
Бинго! И <code>¬¬[Int]</code>, и <code>¬¬[String]</code> являются подтипами <code>Int ∨ String</code>!

Теперь надо проверить, что мы не просто каждый раз возвращаем положительный ответ:
<source lang="Scala">
scala> implicitly[¬¬[Double] <:< (Int ∨ String)]
<console>:12: error: Cannot prove that
  ((Double) => Nothing) => Nothing <:<
    ((Int) => Nothing with (String) => Nothing) => Nothing.
</source>
Итак, мы практически закончили, осталось нанести последние штрихи. Отношения подтипов, которые мы имеем, изоморфны тем, какие мы хотим получить (поскольку тип <code>¬¬[T]</code> изоморфен <code>T</code>). Но у нас пока что нет способа выразить те же отношения с непреобразованными типами, что нам как раз и необходимо.

Мы можем решить эту проблему считая <code>¬[T]</code>, <code>¬¬[T]</code> и <code>T ∨ U</code> фантомными типами и используя их только, чтобы представить требуемые отношения подтипов, а не работая напрямую со значениями данных типов. Вот как это происходит на нашем тестовом примере:
<source lang="Scala">
def size[T](t: T)(implicit ev: (¬¬[T] <:< (Int ∨ String))) =
  t match {
    case i: Int => i
    case s: String => s.length
  }
</source>
Здесь используется обобщённое ограничение типа, требующее, чтобы компилятор мог доказать, что любой <code>T</code>, выведенный как аргумент типа для метода <code>size</code>, удовлетворяет тому, что его двойное отрицание является подтипом <code>Int ∨ String</code>. Как показывает следующая сессия REPL данное условие выполняется только, если <code>T</code> - это <code>Int</code> или <code>String</code>:
<source lang="Scala">
scala> def size[T](t: T)(implicit ev: (¬¬[T] <:< (Int ∨ String))) =
     |   t match {
     |     case i: Int => i
     |     case s: String => s.length
     |   }
size: [T](t: T)(implicit ev: <:<[((T) => Nothing) => Nothing,
  ((Int) => Nothing with (String) => Nothing) => Nothing])Int

scala> size(23)
res8: Int = 23

scala> size("foo")
res9: Int = 3

scala> size(1.0)
<console>:13: error: Cannot prove that
  ((Double) => Nothing) => Nothing <:<
    ((Int) => Nothing with (String) => Nothing) => Nothing.
</source>
А теперь последняя хитрость. С точки зрения синтаксиса неявный параметр доказательства смотрится уродливо и тяжеловесно, однако мы можем это исправить преобразовав его в контекстное ограничение параметра типа <code>T</code>:
<source lang="Scala">
type |∨|[T, U] = { type λ[X] = ¬¬[X] <:< (T ∨ U) }

def size[T: (Int |∨| String)#λ](t: T) =
  t match {
    case i: Int => i
    case s: String => s.length
  }
</source>
Готово! Мы получили незапакованное, статически типобезопасное представление типов объединения в Scala, без модификации самого языка!

Естественно было бы лучше, если бы Scala поддерживала типы объединения как примитивы. Но по крайней мере полученное нами решение демонстрирует, что компилятор Scala имеет всю необходимую информацию, чтобы сделать это. Теперь осталось только донимать Мартина и Адриаана, чтобы они сделали типы объединения доступными напрямую.
